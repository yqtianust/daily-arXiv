{"id": "2506.04418", "pdf": "https://arxiv.org/pdf/2506.04418", "abs": "https://arxiv.org/abs/2506.04418", "authors": ["Noor Nashid", "Daniel Ding", "Keheliya Gallaba", "Ahmed E. Hassan", "Ali Mesbah"], "title": "Characterizing Multi-Hunk Patches: Divergence, Proximity, and LLM Repair Challenges", "categories": ["cs.SE"], "comment": null, "summary": "Multi-hunk bugs, where fixes span disjoint regions of code, are common in\npractice, yet remain underrepresented in automated repair. Existing techniques\nand benchmarks pre-dominantly target single-hunk scenarios, overlooking the\nadded complexity of coordinating semantically related changes across the\ncodebase. In this work, we characterize HUNK4J, a dataset of multi-hunk patches\nderived from 372 real-world defects. We propose hunk divergence, a metric that\nquantifies the variation among edits in a patch by capturing lexical,\nstructural, and file-level differences, while incorporating the number of hunks\ninvolved. We further define spatial proximity, a classification that models how\nhunks are spatially distributed across the program hierarchy. Our empirical\nstudy spanning six LLMs reveals that model success rates decline with increased\ndivergence and spatial dispersion. Notably, when using the LLM alone, no model\nsucceeds in the most dispersed Fragment class. These findings highlight a\ncritical gap in LLM capabilities and motivate divergence-aware repair\nstrategies."}
{"id": "2506.04438", "pdf": "https://arxiv.org/pdf/2506.04438", "abs": "https://arxiv.org/abs/2506.04438", "authors": ["Katerina Goseva-Popstojanova", "Denny Hood", "Johann Schumann", "Noble Nkwocha"], "title": "On the Practices of Autonomous Systems Development: Survey-based Empirical Findings", "categories": ["cs.SE"], "comment": "25 pages", "summary": "Autonomous systems have gained an important role in many industry domains and\nare beginning to change everyday life. However, due to dynamically emerging\napplications and often proprietary constraints, there is a lack of information\nabout the practice of developing autonomous systems. This paper presents the\nfirst part of the longitudinal study focused on establishing\nstate-of-the-practice, identifying and quantifying the challenges and benefits,\nidentifying the processes and standards used, and exploring verification and\nvalidation (V&V) practices used for the development of autonomous systems. The\nresults presented in this paper are based on data about software systems that\nhave autonomous functionality and may employ model-based software engineering\n(MBSwE) and reuse. These data were collected using an anonymous online survey\nthat was administered in 2019 and were provided by experts with experience in\ndevelopment of autonomous systems and /or the use of MBSwE. Our current work is\nfocused on repeating the survey to collect more recent data and discover how\nthe development of autonomous systems has evolved over time."}
{"id": "2506.04464", "pdf": "https://arxiv.org/pdf/2506.04464", "abs": "https://arxiv.org/abs/2506.04464", "authors": ["Oussama Ben Sghaier", "Rosalia Tufano", "Gabriele Bavota", "Houari Sahraoui"], "title": "Leveraging Reward Models for Guiding Code Review Comment Generation", "categories": ["cs.SE", "cs.LG"], "comment": null, "summary": "Code review is a crucial component of modern software development, involving\nthe evaluation of code quality, providing feedback on potential issues, and\nrefining the code to address identified problems. Despite these benefits, code\nreview can be rather time consuming, and influenced by subjectivity and human\nfactors. For these reasons, techniques to (partially) automate the code review\nprocess have been proposed in the literature. Among those, the ones exploiting\ndeep learning (DL) are able to tackle the generative aspect of code review, by\ncommenting on a given code as a human reviewer would do (i.e., comment\ngeneration task) or by automatically implementing code changes required to\naddress a reviewer's comment (i.e., code refinement task). In this paper, we\nintroduce CoRAL, a deep learning framework automating review comment generation\nby exploiting reinforcement learning with a reward mechanism considering both\nthe semantics of the generated comments as well as their usefulness as input\nfor other models automating the code refinement task. The core idea is that if\nthe DL model generates comments that are semantically similar to the expected\nones or can be successfully implemented by a second model specialized in code\nrefinement, these comments are likely to be meaningful and useful, thus\ndeserving a high reward in the reinforcement learning framework. We present\nboth quantitative and qualitative comparisons between the comments generated by\nCoRAL and those produced by the latest baseline techniques, highlighting the\neffectiveness and superiority of our approach."}
{"id": "2506.04509", "pdf": "https://arxiv.org/pdf/2506.04509", "abs": "https://arxiv.org/abs/2506.04509", "authors": ["Kishan Kumar Ganguly", "Tim Menzies"], "title": "BINGO! Simple Optimizers Win Big if Problems Collapse to a Few Buckets", "categories": ["cs.SE"], "comment": null, "summary": "Traditional multi-objective optimization in software engineering (SE) can be\nslow and complex. This paper introduces the BINGO effect: a novel phenomenon\nwhere SE data surprisingly collapses into a tiny fraction of possible solution\n\"buckets\" (e.g., only 100 used from 4,096 expected).\n  We show the BINGO effect's prevalence across 39 optimization in SE problems.\nExploiting this, we optimize 10,000 times faster than state-of-the-art methods,\nwith comparable effectiveness. Our new algorithms (LITE and LINE), demonstrate\nthat simple stochastic selection can match complex optimizers like DEHB. This\nwork explains why simple methods succeed in SE-real data occupies a small\ncorner of possibilities-and guides when to apply them, challenging the need for\nCPU-heavy optimization.\n  Our data and code are public at GitHub (see anon-artifacts/bingo)."}
{"id": "2506.04544", "pdf": "https://arxiv.org/pdf/2506.04544", "abs": "https://arxiv.org/abs/2506.04544", "authors": ["Charles Hong", "Brendan Roberts", "Huijae An", "Alex Um", "Advay Ratan", "Yakun Sophia Shao"], "title": "hdl2v: A Code Translation Dataset for Enhanced LLM Verilog Generation", "categories": ["cs.AR", "cs.AI", "cs.LG", "cs.PL"], "comment": null, "summary": "Large language models (LLMs) are playing an increasingly large role in\ndomains such as code generation, including hardware code generation, where\nVerilog is the key language. However, the amount of publicly available Verilog\ncode pales in comparison to the amount of code available for software languages\nlike Python. In this work, we present hdl2v (\"HDL-to-Verilog\"), a dataset which\nseeks to increase the amount of available human-written Verilog data by\ntranslating or compiling three other hardware description languages - VHDL,\nChisel, and PyMTL3 - to Verilog. Furthermore, we demonstrate the value of hdl2v\nin enhancing LLM Verilog generation by improving performance of a 32\nbillion-parameter open-weight model by up to 23% (pass@10) in VerilogEvalV2,\nwithout utilizing any data augmentation or knowledge distillation from larger\nmodels. We also show hdl2v's ability to boost the performance of a data\naugmentation-based fine-tuning approach by 63%. Finally, we characterize and\nanalyze our dataset to better understand which characteristics of\nHDL-to-Verilog datasets can be expanded upon in future work for even better\nperformance."}
{"id": "2506.04569", "pdf": "https://arxiv.org/pdf/2506.04569", "abs": "https://arxiv.org/abs/2506.04569", "authors": ["Wenwei Gu", "Renyi Zhong", "Guangba Yu", "Xinying Sun", "Jinyang Liu", "Yintong Huo", "Zhuangbin Chen", "Jianping Zhang", "Jiazhen Gu", "Yongqiang Yang", "Michael R. Lyu"], "title": "KPIRoot+: An Efficient Integrated Framework for Anomaly Detection and Root Cause Analysis in Large-Scale Cloud Systems", "categories": ["cs.SE"], "comment": null, "summary": "To ensure the reliability of cloud systems, their performance is monitored\nusing KPIs (key performance indicators). When issues arise, root cause\nlocalization identifies KPIs responsible for service degradation, aiding in\nquick diagnosis and resolution. Traditional methods rely on similarity\ncalculations, which can be ineffective in complex, interdependent cloud\nenvironments. While deep learning-based approaches model these dependencies\nbetter, they often face challenges such as high computational demands and lack\nof interpretability.\n  To address these issues, KPIRoot is proposed as an efficient method combining\nsimilarity and causality analysis. It uses symbolic aggregate approximation for\ncompact KPI representation, improving analysis efficiency. However, deployment\nin Cloud H revealed two drawbacks: 1) threshold-based anomaly detection misses\nsome performance anomalies, and 2) SAX representation fails to capture\nintricate variation trends. KPIRoot+ addresses these limitations, outperforming\neight state-of-the-art baselines by 2.9% to 35.7%, while reducing time cost by\n34.7%. We also share our experience deploying KPIRoot in a large-scale cloud\nprovider's production environment."}
{"id": "2506.04639", "pdf": "https://arxiv.org/pdf/2506.04639", "abs": "https://arxiv.org/abs/2506.04639", "authors": ["Xiaoyu Guo", "Shinobu Saito", "Jianjun Zhao"], "title": "QuanUML: Towards A Modeling Language for Model-Driven Quantum Software Development", "categories": ["cs.SE"], "comment": "A short version of the paper will be appeared in the proceedings of\n  the IEEE Computers, Software, and Applications Conference (COMPSAC 2025) on\n  July 8-11, 2025", "summary": "This paper introduces QuanUML, an extension of the Unified Modeling Language\n(UML) tailored for quantum software systems. QuanUML integrates\nquantum-specific constructs, such as qubits and quantum gates, into the UML\nframework, enabling the modeling of both quantum and hybrid quantum-classical\nsystems. We apply QuanUML to Efficient Long-Range Entanglement using Dynamic\nCircuits and Shor's Algorithm, demonstrating its utility in designing and\nvisualizing quantum algorithms. Our approach supports model-driven development\nof quantum software and offers a structured framework for quantum software\ndesign. We also highlight its advantages over existing methods and discuss\nfuture improvements."}
{"id": "2506.04785", "pdf": "https://arxiv.org/pdf/2506.04785", "abs": "https://arxiv.org/abs/2506.04785", "authors": ["Alisa Welter", "Niklas Schneider", "Tobias Dick", "Kallistos Weis", "Christof Tinnes", "Marvin Wyrich", "Sven Apel"], "title": "From Developer Pairs to AI Copilots: A Comparative Study on Knowledge Transfer", "categories": ["cs.SE"], "comment": null, "summary": "Knowledge transfer is fundamental to human collaboration and is therefore\ncommon in software engineering. Pair programming is a prominent instance. With\nthe rise of AI coding assistants, developers now not only work with human\npartners but also, as some claim, with AI pair programmers. Although studies\nconfirm knowledge transfer during human pair programming, its effectiveness\nwith AI coding assistants remains uncertain. To analyze knowledge transfer in\nboth human-human and human-AI settings, we conducted an empirical study where\ndeveloper pairs solved a programming task without AI support, while a separate\ngroup of individual developers completed the same task using the AI coding\nassistant GitHub Copilot. We extended an existing knowledge transfer framework\nand employed a semi-automated evaluation pipeline to assess differences in\nknowledge transfer episodes across both settings. We found a similar frequency\nof successful knowledge transfer episodes and overlapping topical categories\nacross both settings. Two of our key findings are that developers tend to\naccept GitHub Copilot's suggestions with less scrutiny than those from human\npair programming partners, but also that GitHub Copilot can subtly remind\ndevelopers of important code details they might otherwise overlook."}
{"id": "2506.04987", "pdf": "https://arxiv.org/pdf/2506.04987", "abs": "https://arxiv.org/abs/2506.04987", "authors": ["Zanis Ali Khan", "Aayush Garg", "Qiang Tang"], "title": "A Multi-Dataset Evaluation of Models for Automated Vulnerability Repair", "categories": ["cs.SE", "cs.AI"], "comment": "Preprint has been accepted in ARES AI&CCPS (International Workshop on\n  Artificial Intelligence, Cyber and Cyber-Physical Security)", "summary": "Software vulnerabilities pose significant security threats, requiring\neffective mitigation. While Automated Program Repair (APR) has advanced in\nfixing general bugs, vulnerability patching, a security-critical aspect of APR\nremains underexplored. This study investigates pre-trained language models,\nCodeBERT and CodeT5, for automated vulnerability patching across six datasets\nand four languages. We evaluate their accuracy and generalization to unknown\nvulnerabilities. Results show that while both models face challenges with\nfragmented or sparse context, CodeBERT performs comparatively better in such\nscenarios, whereas CodeT5 excels in capturing complex vulnerability patterns.\nCodeT5 also demonstrates superior scalability. Furthermore, we test fine-tuned\nmodels on both in-distribution (trained) and out-of-distribution (unseen)\ndatasets. While fine-tuning improves in-distribution performance, models\nstruggle to generalize to unseen data, highlighting challenges in robust\nvulnerability detection. This study benchmarks model performance, identifies\nlimitations in generalization, and provides actionable insights to advance\nautomated vulnerability patching for real-world security applications."}
{"id": "2506.04989", "pdf": "https://arxiv.org/pdf/2506.04989", "abs": "https://arxiv.org/abs/2506.04989", "authors": ["Dumitran Adrian Marius", "Dita Radu"], "title": "BacPrep: An Experimental Platform for Evaluating LLM-Based Bacalaureat Assessment", "categories": ["cs.SE"], "comment": "9 pages Preprint ACCEPTED at BBGI (ITS Workshop)", "summary": "Accessing quality preparation and feedback for the Romanian Bacalaureat exam\nis challenging, particularly for students in remote or underserved areas. This\npaper introduces BacPrep, an experimental online platform exploring Large\nLanguage Model (LLM) potential for automated assessment, aiming to offer a\nfree, accessible resource. Using official exam questions from the last 5 years,\nBacPrep employs one of Google's newest models, Gemini 2.0 Flash (released Feb\n2025), guided by official grading schemes, to provide experimental feedback.\nCurrently operational, its primary research function is collecting student\nsolutions and LLM outputs. This focused dataset is vital for planned expert\nvalidation to rigorously evaluate the feasibility and accuracy of this\ncutting-edge LLM in the specific Bacalaureat context before reliable\ndeployment. We detail the design, data strategy, status, validation plan, and\nethics."}
{"id": "2506.05022", "pdf": "https://arxiv.org/pdf/2506.05022", "abs": "https://arxiv.org/abs/2506.05022", "authors": ["Yixuan Cao", "Yuhong Feng", "Huafeng Li", "Chongyi Huang", "Fangcao Jian", "Haoran Li", "Xu Wang"], "title": "Tech-ASan: Two-stage check for Address Sanitizer", "categories": ["cs.SE", "cs.CR"], "comment": null, "summary": "Address Sanitizer (ASan) is a sharp weapon for detecting memory safety\nviolations, including temporal and spatial errors hidden in C/C++ programs\nduring execution. However, ASan incurs significant runtime overhead, which\nlimits its efficiency in testing large software. The overhead mainly comes from\nsanitizer checks due to the frequent and expensive shadow memory access. Over\nthe past decade, many methods have been developed to speed up ASan by\neliminating and accelerating sanitizer checks, however, they either fail to\nadequately eliminate redundant checks or compromise detection capabilities. To\naddress this issue, this paper presents Tech-ASan, a two-stage check based\ntechnique to accelerate ASan with safety assurance. First, we propose a novel\ntwo-stage check algorithm for ASan, which leverages magic value comparison to\nreduce most of the costly shadow memory accesses. Second, we design an\nefficient optimizer to eliminate redundant checks, which integrates a novel\nalgorithm for removing checks in loops. Third, we implement Tech-ASan as a\nmemory safety tool based on the LLVM compiler infrastructure. Our evaluation\nusing the SPEC CPU2006 benchmark shows that Tech-ASan outperforms the\nstate-of-the-art methods with 33.70% and 17.89% less runtime overhead than ASan\nand ASan--, respectively. Moreover, Tech-ASan detects 56 fewer false negative\ncases than ASan and ASan-- when testing on the Juliet Test Suite under the same\nredzone setting."}
{"id": "2506.05079", "pdf": "https://arxiv.org/pdf/2506.05079", "abs": "https://arxiv.org/abs/2506.05079", "authors": ["Shengcheng Yu", "Yuchen Ling", "Chunrong Fang", "Quan Zhou", "Chunyang Chen", "Shaomin Zhu", "Zhenyu Chen"], "title": "LLM-Guided Scenario-based GUI Testing", "categories": ["cs.SE"], "comment": null, "summary": "The assurance of mobile app GUI is more and more significant. Automated GUI\ntesting approaches of different strategies have been developed, while there are\nstill huge gaps between the approaches and the app business logic, not taking\nthe completion of specific testing scenarios as the exploration target, leading\nto the exploration missing of critical app functionalities. Learning from the\nmanual testing, which takes testing scenarios with app business logic as the\nbasic granularity, in this paper, we utilize the LLMs to understand the\nsemantics presented in app GUI and how they are mapped in the testing context\nbased on specific testing scenarios. Then, scenario-based GUI tests are\ngenerated with the guidance of multi-agent collaboration. Specifically, we\npropose ScenGen, a novel LLM-guided scenario-based GUI testing approach\ninvolving five agents to respectively take responsibilities of different phases\nof the manual testing process. The Observer perceives the app GUI state by\nextracting GUI widgets and forming GUI layouts, understanding the expressed\nsemantics. Then the app GUI info is sent to the Decider to make decisions on\ntarget widgets based on the target testing scenarios. The decision-making\nprocess takes the completion of specific testing scenarios as the exploration\ntarget. The Executor then executes the demanding operations on the apps. The\nexecution results are checked by the Supervisor on whether the generated tests\nare consistent with the completion target of the testing scenarios, ensuring\nthe traceability of the test generation and execution. Furthermore, the\ncorresponding GUI test operations are recorded to the context memory by\nRecorder as an important basis for further decision-making, meanwhile\nmonitoring the runtime bug occurrences. ScenGen is evaluated and the results\nshow that ScenGen can effectively generate scenario-based GUI tests guided by\nLLMs."}
{"id": "2506.04791", "pdf": "https://arxiv.org/pdf/2506.04791", "abs": "https://arxiv.org/abs/2506.04791", "authors": ["Athanasios C. Antoulas", "Ion Victor Gosea", "Charles Poussot-Vassal", "Pierre Vuillemin"], "title": "Tensor-based multivariate function approximation: methods benchmarking and comparison", "categories": ["math.NA", "cs.CE", "cs.NA", "cs.SE", "93A15, 93A30, 93B11, 93B15, 93C05, 93C80"], "comment": "Report with a collection of examples, aimed at being regularly\n  updated. Associated GIT: https://github.com/cpoussot/mLF", "summary": "In this note, we evaluate the performances, the features and the\nuser-experience of some methods (and their implementations) designed for\ntensor- (or data-) based multivariate function construction and approximation.\nTo this aim, a collection of multivariate functions extracted from contributive\nworks coming from different communities, is suggested. First, these functions\nwith varying complexity (e.g. number and degree of the variables) and nature\n(e.g. rational, irrational, differentiable or not, symmetric, etc.) are used to\nconstruct tensors, each of different dimension and size on the disk. Second,\ngrounded on this tensor, we inspect performances of each considered method\n(e.g. the accuracy, the computational time, the parameters tuning impact,\netc.). Finally, considering the \"best\" parameter tuning set, we compare each\nmethod using multiple evaluation criteria. The purpose of this note is not to\nrank the methods but rather to evaluate as fairly as possible the different\navailable strategies, with the idea in mind to guide users to understand the\nprocess, the possibilities, the advantages and the limits brought by each\ntools. The contribution claimed is to suggest a complete benchmark collection\nof some available tools for tensor approximation by surrogate models (e.g.\nrational functions, networks, etc.). In addition, as contributors of the\nmultivariate Loewner Framework (mLF) approach (and its side implementation in\nMDSPACK), attention and details of the latter are more explicitly given, in\norder to provide readers a digest of this contributive work and some details\nwith simple examples."}
{"id": "2506.04962", "pdf": "https://arxiv.org/pdf/2506.04962", "abs": "https://arxiv.org/abs/2506.04962", "authors": ["Deniz Simsek", "Aryaz Eghbali", "Michael Pradel"], "title": "PoCGen: Generating Proof-of-Concept Exploits for Vulnerabilities in Npm Packages", "categories": ["cs.CR", "cs.SE"], "comment": null, "summary": "Security vulnerabilities in software packages are a significant concern for\ndevelopers and users alike. Patching these vulnerabilities in a timely manner\nis crucial to restoring the integrity and security of software systems.\nHowever, previous work has shown that vulnerability reports often lack\nproof-of-concept (PoC) exploits, which are essential for fixing the\nvulnerability, testing patches, and avoiding regressions. Creating a PoC\nexploit is challenging because vulnerability reports are informal and often\nincomplete, and because it requires a detailed understanding of how inputs\npassed to potentially vulnerable APIs may reach security-relevant sinks. In\nthis paper, we present PoCGen, a novel approach to autonomously generate and\nvalidate PoC exploits for vulnerabilities in npm packages. This is the first\nfully autonomous approach to use large language models (LLMs) in tandem with\nstatic and dynamic analysis techniques for PoC exploit generation. PoCGen\nleverages an LLM for understanding vulnerability reports, for generating\ncandidate PoC exploits, and for validating and refining them. Our approach\nsuccessfully generates exploits for 77% of the vulnerabilities in the\nSecBench.js dataset and 39% in a new, more challenging dataset of 794 recent\nvulnerabilities. This success rate significantly outperforms a recent baseline\n(by 45 absolute percentage points), while imposing an average cost of $0.02 per\ngenerated exploit."}
